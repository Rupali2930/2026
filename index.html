<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Samja ki nhi</title>
  <style>
    :root {
      --accent: #7be8ff;
      --accent-2: #ffd6f9;
      --text: #f4f8ff;
      --card: rgba(12, 16, 42, 0.72);
      --success: #7dffbe;
      --warning: #ffd88a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      color: var(--text);
      background: #020615;
      overflow-x: hidden;
    }

    .sky-layer {
      position: fixed;
      inset: 0;
      z-index: -4;
      pointer-events: none;
    }

    #nebula-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: -3;
      pointer-events: none;
    }

    .horizon {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 36vh;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(60% 18% at 50% 70%, rgba(140, 210, 255, 0.28), transparent 75%),
        linear-gradient(180deg, rgba(8, 16, 36, 0.08), rgba(3, 8, 20, 0.88) 55%, #02040b 100%);
    }

    .horizon::before {
      content: "";
      position: absolute;
      inset: 30% -2% 0;
      background: #02040b;
      clip-path: polygon(0 62%, 8% 58%, 20% 60%, 31% 57%, 44% 61%, 57% 56%, 69% 60%, 82% 58%, 100% 62%, 100% 100%, 0 100%);
      opacity: 0.9;
    }

    @keyframes nebulaShift {
      from {
        transform: translateX(-2%) translateY(-1%) scale(1);
        opacity: .76;
      }

      to {
        transform: translateX(3%) translateY(1%) scale(1.05);
        opacity: 1;
      }
    }

    #stars {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
    }

    .app {
      width: min(680px, 92vw);
      margin: 2rem auto;
      padding: 1rem;
    }

    .panel {
      display: none;
      background: var(--card);
      border: 1px solid rgba(199, 222, 255, 0.24);
      border-radius: 20px;
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 45px rgba(5, 9, 25, 0.38);
      padding: 1.4rem;
      position: relative;
      z-index: 10;
      animation: rise .5s cubic-bezier(.22, .68, .36, 1.2);
    }

    .panel.active {
      display: block;
    }

    @keyframes rise {
      from {
        opacity: 0;
        transform: translateY(16px) scale(0.97);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Star streak - CSS animated horizontal shooting stars */
    .star-streak {
      position: fixed;
      pointer-events: none;
      z-index: -1;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: white;
      box-shadow: 0 0 6px 2px rgba(180, 220, 255, 0.8), 0 0 14px 4px rgba(123, 200, 255, 0.4);
      animation: streakAcross 5s linear forwards;
    }

    .star-streak::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 100%;
      transform-origin: 100% 50%;
      transform: translateY(-50%);
      width: 80px;
      height: 2px;
      background: linear-gradient(to left, rgba(200, 230, 255, 0.7), rgba(150, 200, 255, 0.3) 40%, transparent);
      border-radius: 2px;
    }

    @keyframes streakAcross {
      0% {
        left: -100px;
        top: var(--start-y);
        transform: rotate(-5deg);
        opacity: 0;
      }

      10% {
        opacity: 1;
      }

      50% {
        left: 60vw;
        top: calc(var(--start-y) + 15vh);
        transform: rotate(20deg);
        opacity: 1;
      }

      100% {
        left: 90vw;
        top: calc(var(--start-y) + 90vh);
        transform: rotate(70deg);
        opacity: 0;
      }
    }



    #star-container {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      /* Mask out the center where the panel is */
      mask-image: radial-gradient(ellipse 360px 500px at center, transparent 0%, transparent 60%, black 100%);
      -webkit-mask-image: radial-gradient(ellipse 360px 400px at center, transparent 0%, transparent 70%, black 95%);
    }

    /* Progress bar */
    .progress-wrap {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.06);
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2), #b28dff);
      border-radius: 0 2px 2px 0;
      transition: width 0.6s ease;
      box-shadow: 0 0 12px rgba(123, 232, 255, 0.5);
    }

    /* Typewriter cursor */
    .typewriter-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--accent);
      margin-left: 2px;
      animation: blink 0.7s step-end infinite;
      vertical-align: text-bottom;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    h1,
    h2,
    h3 {
      margin: 0.4rem 0 0.8rem;
    }

    p {
      line-height: 1.5;
      opacity: 0.95;
    }

    .lead {
      font-size: clamp(1rem, 2.4vw, 1.15rem);
      max-width: 62ch;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: .75rem;
      margin-top: 1rem;
    }

    button {
      border: 0;
      border-radius: 999px;
      padding: .7rem 1rem;
      font-weight: 650;
      cursor: pointer;
      color: #0b1538;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 8px 24px rgba(116, 196, 255, 0.3);
      transition: transform .15s ease, box-shadow .15s ease;
    }

    button:hover {
      transform: translateY(-1px) scale(1.01);
    }

    button:active {
      transform: translateY(1px) scale(.99);
    }

    .subtle {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, .2);
    }

    .hud {
      margin: .8rem 0;
      font-size: .95rem;
      color: var(--accent-2);
    }

    .status {
      margin-top: .7rem;
      min-height: 1.5rem;
      font-weight: 550;
    }

    .ok {
      color: var(--success);
    }

    .warn {
      color: var(--warning);
    }

    .selector-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: .6rem;
      margin-top: .8rem;
    }

    .game-option {
      border: 1px solid rgba(255, 255, 255, .2);
      border-radius: 12px;
      background: rgba(255, 255, 255, .08);
      padding: .7rem;
      display: flex;
      align-items: center;
      gap: .55rem;
      cursor: pointer;
      user-select: none;
    }

    .game-option input {
      accent-color: #8ce7ff;
    }

    .tiny {
      font-size: .86rem;
      opacity: .88;
    }

    #star-game {
      position: relative;
      width: 100%;
      height: 220px;
      overflow: hidden;
      border-radius: 14px;
      border: 1px dashed rgba(155, 225, 255, 0.35);
      background: radial-gradient(circle at center, rgba(123, 232, 255, .08), transparent 60%);
    }

    .star-click {
      position: absolute;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      cursor: pointer;
      color: #ffe88f;
      font-size: 1.1rem;
      text-shadow: 0 0 12px rgba(255, 238, 170, 0.9);
      animation: pulse 1.4s ease-in-out infinite;
      user-select: none;
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.18);
      }
    }

    #constellation {
      width: 100%;
      max-width: 550px;
      height: min(40vw, 260px);
      border-radius: 14px;
      border: 1px dashed rgba(155, 225, 255, 0.35);
      background: rgba(1, 4, 18, .55);
      touch-action: none;
      cursor: crosshair;
    }

    .memory-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: .6rem;
      margin-top: .8rem;
      max-width: 480px;
      margin-left: auto;
      margin-right: auto;
    }

    .card {
      aspect-ratio: 1/1;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      perspective: 600px;
      min-height: 90px;
    }

    .card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.45s ease;
      transform-style: preserve-3d;
    }

    .card.flipped .card-inner,
    .card.matched .card-inner {
      transform: rotateY(180deg);
    }

    .card-front,
    .card-back {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      display: grid;
      place-items: center;
    }

    .card-back {
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .2);
      font-size: 1.6rem;
      color: rgba(200, 220, 255, 0.6);
    }

    .card-front {
      transform: rotateY(180deg);
      overflow: hidden;
      border: 2px solid rgba(123, 232, 255, .35);
      box-shadow: 0 0 12px rgba(100, 200, 255, 0.15);
    }

    .card-front img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 10px;
    }

    .card.matched .card-front {
      border-color: rgba(100, 255, 180, 0.5);
      box-shadow: 0 0 16px rgba(100, 255, 180, 0.2);
    }

    .card:hover .card-inner {
      transform: scale(1.03);
    }

    .card.flipped:hover .card-inner,
    .card.matched:hover .card-inner {
      transform: rotateY(180deg) scale(1.03);
    }

    #meteor-game {
      position: relative;
      width: 100%;
      height: 220px;
      border-radius: 14px;
      border: 1px dashed rgba(155, 225, 255, 0.35);
      background: linear-gradient(180deg, rgba(10, 20, 44, .65), rgba(5, 11, 28, .5));
      overflow: hidden;
      touch-action: none;
    }

    #ship {
      position: absolute;
      width: 44px;
      height: 44px;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      display: grid;
      place-items: center;
      font-size: 1.4rem;
      filter: drop-shadow(0 0 8px rgba(160, 220, 255, 0.8));
    }

    .meteor {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 14px rgba(255, 162, 105, 0.38), 0 0 6px rgba(255, 200, 150, 0.3);
    }

    .meteor img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }

    .planet-wrap {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: .8rem;
      margin-top: .8rem;
    }

    .choice-chip {
      border: 1px solid rgba(255, 255, 255, .25);
      border-radius: 12px;
      background: rgba(255, 255, 255, .06);
      padding: .5rem;
    }

    select {
      width: 100%;
      margin-top: .35rem;
      padding: .5rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .2);
      background: rgba(7, 12, 30, .72);
      color: var(--text);
    }

    .final-box {
      text-align: center;
      padding: 1.2rem;
      border: 1px solid rgba(123, 232, 255, .32);
      border-radius: 14px;
      background: rgba(9, 21, 56, .35);
      margin-top: .8rem;
    }

    /* Planet builder */
    .planet-scene {
      display: flex;
      flex-wrap: wrap;
      gap: 1.2rem;
      align-items: flex-start;
      margin-top: .8rem;
    }

    .planet-visual {
      flex: 1 1 180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: .6rem;
    }

    .planet-sphere {
      width: 130px;
      height: 130px;
      border-radius: 50%;
      position: relative;
      animation: planetSpin 12s linear infinite;
      box-shadow:
        inset -30px -10px 40px rgba(0, 0, 0, 0.4),
        inset 10px 10px 25px rgba(255, 255, 255, 0.08),
        0 0 40px rgba(123, 200, 255, 0.25),
        0 0 80px rgba(123, 200, 255, 0.1);
      transition: background 0.6s ease, box-shadow 0.6s ease;
      background: radial-gradient(circle at 35% 35%, #5b8fff, #1a3a8a 60%, #0a1535);
    }

    .planet-ring {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 190px;
      height: 40px;
      border: 2px solid rgba(200, 220, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%) rotateX(72deg);
      pointer-events: none;
      transition: border-color 0.5s, width 0.5s;
    }

    @keyframes planetSpin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .planet-label {
      text-align: center;
      font-size: .85rem;
      color: var(--accent-2);
      min-height: 2.4em;
    }

    .planet-options {
      flex: 1 1 240px;
    }

    .planet-options .choice-chip {
      margin-bottom: .6rem;
    }

    .planet-options .choice-chip label {
      display: block;
      font-weight: 600;
      margin-bottom: .25rem;
      font-size: .9rem;
    }

    .planet-card {
      margin-top: .8rem;
      padding: .8rem;
      border-radius: 12px;
      border: 1px solid rgba(123, 232, 255, .2);
      background: rgba(10, 20, 50, .4);
      text-align: center;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.4s, transform 0.4s;
    }

    .planet-card.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .planet-card h3 {
      margin: 0 0 .4rem;
      color: var(--accent);
      font-size: 1rem;
    }

    .planet-card p {
      margin: .2rem 0;
      font-size: .9rem;
    }
  </style>
</head>

<body>
  <div class="progress-wrap">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div class="sky-layer"></div>
  <canvas id="nebula-canvas"></canvas>
  <canvas id="stars"></canvas>
  <div class="horizon"></div>

  <div id="star-container"></div>
  <main class="app">
    <section class="panel active" id="scene-intro">
      <h1>Hi shriniket üåå</h1>
      <p class="lead">I made this little cosmic journey for you. Choose which games you want to keep, then start.</p>
      <h3>Pick your game lineup (you can remove any later)</h3>
      <div class="selector-grid" id="gameSelector">
        <label class="game-option"><input type="checkbox" data-game="stars" checked /> ‚≠ê Catch stars <span
            class="tiny">(easy)</span></label>
        <label class="game-option"><input type="checkbox" data-game="memory" checked /> üÉè Memory match <span
            class="tiny">(classic)</span></label>
        <label class="game-option"><input type="checkbox" data-game="meteor" checked /> ‚òÑÔ∏è Meteor dodge <span
            class="tiny">(new)</span></label>
        <label class="game-option"><input type="checkbox" data-game="planet" checked /> ü™ê Build-a-date planet <span
            class="tiny">(new)</span></label>
      </div>
      <div class="btn-row">
        <button id="startJourney">Start the journey ‚ú®</button>
      </div>
      <p id="introNote" class="status"></p>
    </section>

    <section class="panel" id="scene-stars">
      <h2>Game 1: Catch the Shooting Stars ‚≠ê</h2>
      <p>Tap/click <strong>12 stars</strong> to gather enough stardust.</p>
      <div class="hud" id="starScore">Stars collected: 0 / 12</div>
      <div id="star-game"></div>
      <div class="btn-row">
        <button id="toConstellation" class="subtle" disabled>Continue</button>
        <button id="skipStars" class="subtle">Skip (test)</button>
      </div>
    </section>

    <section class="panel" id="scene-constellation">
      <h2>Game 2: Connect the Constellation</h2>
      <p>Drag smoothly from point 1 to 6. The path snaps gently when you move near each star.</p>
      <div class="hud" id="constellationHint">Progress: 0 / 6 points</div>
      <canvas id="constellation" width="700" height="380"></canvas>
      <div class="btn-row">
        <button id="toMemory" class="subtle" disabled>Continue</button>
        <button id="skipConstellation" class="subtle">Skip (test)</button>
      </div>
    </section>

    <section class="panel" id="scene-memory">
      <h2>Game 2: Memory Match üÉè</h2>
      <p>Match all pairs to unlock the next scene.</p>
      <div class="hud" id="memoryScore">Pairs found: 0 / 4</div>
      <div class="memory-grid" id="memoryGrid"></div>
      <div class="btn-row">
        <button id="toMeteor" class="subtle" disabled>Continue</button>
        <button id="skipMemory" class="subtle">Skip (test)</button>
      </div>
    </section>

    <section class="panel" id="scene-meteor">
      <h2>Game 3: Meteor Dodge ‚òÑÔ∏è</h2>
      <p>Move the ship and survive for <strong>18 seconds</strong>.</p>
      <div class="hud" id="meteorHud">Survival: 0.0s / 18.0s</div>
      <div id="meteor-game">
        <div id="ship">üöÄ</div>
      </div>
      <div class="btn-row">
        <button id="toPlanet" class="subtle" disabled>Continue</button>
        <button id="skipMeteor" class="subtle">Skip (test)</button>
      </div>
      <p id="meteorStatus" class="status"></p>
    </section>

    <section class="panel" id="scene-planet">
      <h2>Game 4: Build Our Date Planet ü™ê</h2>
      <p>Every choice shapes your planet. Pick what feels right ‚Äî watch it transform!</p>
      <div class="planet-scene">
        <div class="planet-visual">
          <div class="planet-sphere" id="planetSphere">
            <div class="planet-ring" id="planetRing"></div>
          </div>
          <div class="planet-label" id="planetLabel">Your planet awaits...</div>
        </div>
        <div class="planet-options">
          <div class="choice-chip">
            <label>üçΩÔ∏è What should we eat?</label>
            <select id="foodChoice">
              <option value="">Choose...</option>
              <option>Pizza üçï</option>
              <option>Cafe ‚òï</option>
              <option>Street food üåÆ</option>
              <option>Dessert üç∞</option>
              <option>Sushi üç£</option>
              <option>Home cooked üç≥</option>
            </select>
          </div>
          <div class="choice-chip">
            <label>üéµ What's the vibe?</label>
            <select id="vibeChoice">
              <option value="">Choose...</option>
              <option>Cozy walk üåô</option>
              <option>Music + chat üéß</option>
              <option>Movie night üé¨</option>
              <option>Sunset point üåÖ</option>
              <option>Stargazing üå†</option>
              <option>Adventure üé¢</option>
            </select>
          </div>
          <div class="choice-chip">
            <label>üìç Where should we go?</label>
            <select id="spotChoice">
              <option value="">Choose...</option>
              <option>Rooftop ‚ú®</option>
              <option>Park üå≥</option>
              <option>Cafe corner üïØÔ∏è</option>
              <option>Lakeside üíß</option>
              <option>Beach üèñÔ∏è</option>
              <option>Hilltop ‚õ∞Ô∏è</option>
            </select>
          </div>
        </div>
      </div>
      <div class="planet-card" id="planetCard">
        <h3>ü™ê Your Date Planet</h3>
        <p id="planetSummary"></p>
      </div>
      <div class="btn-row">
        <button id="savePlanet" class="subtle">Lock this planet üîí</button>
        <button id="toFinal" class="subtle" disabled>Reveal final message üíå</button>
      </div>
      <p id="planetStatus" class="status"></p>
    </section>

    <section class="panel" id="scene-final">
      <h2>A final message üí´</h2>
      <div class="final-box">
        <p id="finalMessage"></p>
        <p id="datePlan" class="tiny"></p>
        <div class="btn-row" style="justify-content:center;">
          <button id="yesBtn">Yes, let's do it üíñ</button>
          <button id="maybeBtn" class="subtle">I need a little time üåô</button>
          <button id="friendsBtn" class="subtle">Let's stay friends ü´Ç</button>
        </div>
        <p id="response" class="status"></p>
      </div>
      <div class="btn-row" style="justify-content:center;">
        <button id="restart" class="subtle">Restart journey</button>
      </div>
    </section>
  </main>

  <script>
    const scenes = {
      intro: document.getElementById('scene-intro'),
      stars: document.getElementById('scene-stars'),
      constellation: document.getElementById('scene-constellation'),
      memory: document.getElementById('scene-memory'),
      meteor: document.getElementById('scene-meteor'),
      planet: document.getElementById('scene-planet'),
      final: document.getElementById('scene-final')
    };

    const state = {
      name: 'Batman',
      stars: 0,
      constellationIndex: 0,
      matches: 0,
      locked: false,
      selectedGames: ['stars', 'constellation', 'memory', 'meteor', 'planet'],
      sceneOrder: [],
      datePlan: '',
      meteor: { active: false, timer: 0, won: false }
    };

    const orderedGames = ['stars', 'memory', 'meteor', 'planet'];

    function updateProgress() {
      const total = state.sceneOrder.length;
      if (!total) return;
      const current = state.sceneOrder.indexOf(currentScene);
      const pct = Math.min(100, ((current) / (total - 1)) * 100);
      document.getElementById('progressBar').style.width = pct + '%';
    }
    let currentScene = 'intro';

    function showScene(key) {
      Object.values(scenes).forEach(s => s.classList.remove('active'));
      scenes[key].classList.add('active');
      currentScene = key;
      updateProgress();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function nextSceneFrom(current) {
      const i = state.sceneOrder.indexOf(current);
      return i >= 0 && i < state.sceneOrder.length - 1 ? state.sceneOrder[i + 1] : 'final';
    }

    function computeSelectedGames() {
      const selected = [...document.querySelectorAll('#gameSelector input:checked')].map(i => i.dataset.game);
      return orderedGames.filter(g => selected.includes(g));
    }

    document.getElementById('startJourney').addEventListener('click', () => {
      const introNote = document.getElementById('introNote');
      state.selectedGames = computeSelectedGames();
      if (!state.selectedGames.length) {
        introNote.textContent = 'Pick at least one game first ‚ú®';
        introNote.className = 'status warn';
        return;
      }
      introNote.textContent = `Lineup: ${state.selectedGames.join(' ‚Üí ')} ‚Üí final`;
      introNote.className = 'status ok';
      state.sceneOrder = ['intro', ...state.selectedGames, 'final'];
      showScene(state.selectedGames[0]);
      if (state.selectedGames[0] === 'meteor') startMeteorGame();
    });

    // Game 1: stars
    const starField = document.getElementById('star-game');
    const starScore = document.getElementById('starScore');
    const toConstellation = document.getElementById('toConstellation');
    function spawnClickStar() {
      if (state.stars >= 12 || !scenes.stars.classList.contains('active')) return;
      const s = document.createElement('div');
      s.className = 'star-click';
      s.textContent = '‚ú¶';
      s.style.left = `${Math.random() * (starField.clientWidth - 34)}px`;
      s.style.top = `${Math.random() * (starField.clientHeight - 34)}px`;
      s.addEventListener('click', () => {
        state.stars += 1;
        starScore.textContent = `Stars collected: ${state.stars} / 12`;
        s.remove();
        if (state.stars >= 12) {
          toConstellation.disabled = false;
          celebrateGameComplete();
        }
      }, { once: true });
      starField.appendChild(s);
      setTimeout(() => s.remove(), 1800);
    }
    setInterval(spawnClickStar, 420);
    toConstellation.addEventListener('click', () => {
      const next = nextSceneFrom('stars');
      showScene(next);
      if (next === 'meteor') startMeteorGame();
    });

    // Skip button for testing
    document.getElementById('skipStars').addEventListener('click', () => {
      const next = nextSceneFrom('stars');
      showScene(next);
      if (next === 'meteor') startMeteorGame();
    });

    // Game 2: constellation (smooth drag)
    const constellationCanvas = document.getElementById('constellation');
    const cctx = constellationCanvas.getContext('2d');
    const constellationHint = document.getElementById('constellationHint');
    const toMemory = document.getElementById('toMemory');
    const basePoints = [
      { x: 0.13, y: 0.52 }, { x: 0.26, y: 0.30 }, { x: 0.42, y: 0.32 },
      { x: 0.50, y: 0.54 }, { x: 0.61, y: 0.31 }, { x: 0.76, y: 0.33 }
    ];
    const drag = { active: false, x: 0, y: 0, trail: [] };

    function fitConstellationCanvas() {
      const rect = constellationCanvas.getBoundingClientRect();
      constellationCanvas.width = Math.floor(rect.width * window.devicePixelRatio);
      constellationCanvas.height = Math.floor(rect.height * window.devicePixelRatio);
      cctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
      drawConstellation();
    }
    function getPoints() {
      const w = constellationCanvas.clientWidth;
      const h = constellationCanvas.clientHeight;
      return basePoints.map((p) => ({ x: p.x * w, y: p.y * h }));
    }
    function pointerToCanvas(ev) {
      const rect = constellationCanvas.getBoundingClientRect();
      return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    }
    function isNear(p, x, y, r = 28) { return Math.hypot(p.x - x, p.y - y) <= r; }

    function drawConstellation() {
      const points = getPoints();
      const w = constellationCanvas.clientWidth;
      const h = constellationCanvas.clientHeight;
      cctx.clearRect(0, 0, w, h);
      const bg = cctx.createRadialGradient(w * 0.5, h * 0.45, 40, w * 0.5, h * 0.45, Math.max(w, h));
      bg.addColorStop(0, 'rgba(105,170,255,.14)');
      bg.addColorStop(1, 'rgba(1,4,18,.04)');
      cctx.fillStyle = bg;
      cctx.fillRect(0, 0, w, h);

      if (state.constellationIndex > 0) {
        cctx.beginPath();
        cctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < state.constellationIndex; i++) cctx.lineTo(points[i].x, points[i].y);
        if (drag.active && state.constellationIndex < points.length) cctx.lineTo(drag.x, drag.y);
        cctx.strokeStyle = 'rgba(123, 232, 255, 0.95)';
        cctx.lineWidth = 3.5;
        cctx.shadowBlur = 14;
        cctx.shadowColor = '#7be8ff';
        cctx.lineCap = 'round';
        cctx.lineJoin = 'round';
        cctx.stroke();
      }

      drag.trail.slice(-12).forEach((t, i, arr) => {
        const alpha = (i + 1) / arr.length;
        cctx.beginPath();
        cctx.arc(t.x, t.y, 2.2, 0, Math.PI * 2);
        cctx.fillStyle = `rgba(170, 226, 255, ${alpha * 0.35})`;
        cctx.fill();
      });

      points.forEach((p, i) => {
        cctx.beginPath();
        cctx.arc(p.x, p.y, 10.5, 0, Math.PI * 2);
        cctx.fillStyle = i < state.constellationIndex ? '#9fe8ff' : 'rgba(255,255,255,.30)';
        cctx.fill();
        cctx.strokeStyle = i === state.constellationIndex ? 'rgba(255, 245, 186, .9)' : 'rgba(255,255,255,.25)';
        cctx.lineWidth = i === state.constellationIndex ? 2.2 : 1;
        cctx.stroke();
      });
      cctx.shadowBlur = 0;
    }

    function completeTargetIfNear(x, y) {
      const points = getPoints();
      const target = points[state.constellationIndex];
      if (!target || !isNear(target, x, y)) return;
      drag.x = target.x;
      drag.y = target.y;
      state.constellationIndex += 1;
      constellationHint.textContent = `Progress: ${state.constellationIndex} / 6 points`;
      if (state.constellationIndex >= points.length) {
        constellationHint.textContent = 'Heart constellation complete!';
        toMemory.disabled = false;
        drag.active = false;
        celebrateGameComplete();
      }
    }

    constellationCanvas.addEventListener('pointerdown', (ev) => {
      if (!scenes.constellation.classList.contains('active') || state.constellationIndex >= basePoints.length) return;
      const pos = pointerToCanvas(ev);
      const first = getPoints()[0];
      if (state.constellationIndex === 0 && !isNear(first, pos.x, pos.y, 30)) return;
      drag.active = true;
      drag.x = pos.x;
      drag.y = pos.y;
      drag.trail = [pos];
      if (state.constellationIndex === 0) completeTargetIfNear(pos.x, pos.y);
      constellationCanvas.setPointerCapture(ev.pointerId);
      drawConstellation();
    });
    constellationCanvas.addEventListener('pointermove', (ev) => {
      if (!drag.active || state.constellationIndex >= basePoints.length) return;
      const pos = pointerToCanvas(ev);
      drag.x = pos.x;
      drag.y = pos.y;
      drag.trail.push(pos);
      if (drag.trail.length > 20) drag.trail.shift();
      completeTargetIfNear(pos.x, pos.y);
      drawConstellation();
    });
    function endDrag() {
      if (!drag.active) return;
      drag.active = false;
      drag.trail = [];
      drawConstellation();
    }
    constellationCanvas.addEventListener('pointerup', endDrag);
    constellationCanvas.addEventListener('pointercancel', endDrag);
    toMemory.addEventListener('click', () => {
      const next = nextSceneFrom('constellation');
      showScene(next);
      if (next === 'meteor') startMeteorGame();
    });
    document.getElementById('skipConstellation').addEventListener('click', () => {
      const next = nextSceneFrom('constellation');
      showScene(next);
      if (next === 'meteor') startMeteorGame();
    });
    fitConstellationCanvas();

    // Game 3: memory (photo cards)
    const memoryGrid = document.getElementById('memoryGrid');
    const memoryScore = document.getElementById('memoryScore');
    const toMeteor = document.getElementById('toMeteor');
    const photoCards = [
      'IMG_0702.jpg',
      '880c4c54-f993-4c67-a595-e8084eb41da3.jpeg',
      'IMG20260103233432.jpeg',
      'IMG20260105140611.jpeg'
    ];
    const cards = [...photoCards, ...photoCards]
      .map(v => ({ v, id: Math.random() }))
      .sort((a, b) => a.id - b.id);
    let firstCard = null;
    cards.forEach((item) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.value = item.v;

      const inner = document.createElement('div');
      inner.className = 'card-inner';

      const back = document.createElement('div');
      back.className = 'card-back';
      back.textContent = '‚úß';

      const front = document.createElement('div');
      front.className = 'card-front';
      const img = document.createElement('img');
      img.src = item.v;
      img.alt = 'memory card';
      img.draggable = false;
      front.appendChild(img);

      inner.appendChild(back);
      inner.appendChild(front);
      card.appendChild(inner);

      card.addEventListener('click', () => {
        if (state.locked || card.classList.contains('matched') || card.classList.contains('flipped')) return;
        card.classList.add('flipped');
        if (!firstCard) { firstCard = card; return; }
        if (firstCard.dataset.value === card.dataset.value) {
          firstCard.classList.add('matched');
          card.classList.add('matched');
          firstCard = null;
          state.matches += 1;
          memoryScore.textContent = `Pairs found: ${state.matches} / 4`;
          if (state.matches === 4) {
            toMeteor.disabled = false;
            celebrateGameComplete();
          }
          return;
        }
        state.locked = true;
        const prev = firstCard;
        setTimeout(() => {
          card.classList.remove('flipped');
          prev.classList.remove('flipped');
          firstCard = null;
          state.locked = false;
        }, 800);
      });
      memoryGrid.appendChild(card);
    });
    toMeteor.addEventListener('click', () => {
      const next = nextSceneFrom('memory');
      showScene(next);
      if (next === 'meteor') startMeteorGame();
    });

    // Skip button for testing
    document.getElementById('skipMemory').addEventListener('click', () => {
      const next = nextSceneFrom('memory');
      showScene(next);
      if (next === 'meteor') startMeteorGame();
    });

    // Game 4: meteor dodge (new)
    const meteorGame = document.getElementById('meteor-game');
    const ship = document.getElementById('ship');
    const meteorHud = document.getElementById('meteorHud');
    const toPlanet = document.getElementById('toPlanet');
    const meteorStatus = document.getElementById('meteorStatus');
    let meteorInterval = null;
    let meteorAnim = null;
    const meteorItems = [];
    const shipPos = { x: 0.5 };

    function resetMeteor() {
      meteorItems.splice(0, meteorItems.length).forEach(m => m.el.remove());
      state.meteor.timer = 0;
      state.meteor.won = false;
      meteorHud.textContent = 'Survival: 0.0s / 18.0s';
      meteorStatus.textContent = '';
      toPlanet.disabled = true;
      shipPos.x = 0.5;
      ship.style.left = '50%';
    }

    function spawnMeteor() {
      if (!state.meteor.active) return;
      const m = document.createElement('div');
      m.className = 'meteor';
      const img = document.createElement('img');
      img.src = '880c4c54-f993-4c67-a595-e8084eb41da3.jpeg';
      img.alt = '';
      img.draggable = false;
      m.appendChild(img);
      const x = Math.random() * (meteorGame.clientWidth - 30);
      m.style.left = `${x}px`;
      m.style.top = '-32px';
      meteorGame.appendChild(m);
      meteorItems.push({ el: m, x, y: -32, vy: 2.2 + Math.random() * 1.4 });
    }

    function checkShipCollision(m) {
      const shipRect = ship.getBoundingClientRect();
      const meteorRect = m.el.getBoundingClientRect();
      return !(meteorRect.right < shipRect.left || meteorRect.left > shipRect.right || meteorRect.bottom < shipRect.top || meteorRect.top > shipRect.bottom);
    }

    let meteorLastTime = 0;

    function meteorLoop(timestamp) {
      if (!state.meteor.active) return;
      if (!meteorLastTime) meteorLastTime = timestamp;
      const dt = (timestamp - meteorLastTime) / 1000;
      meteorLastTime = timestamp;
      state.meteor.timer += dt;
      meteorHud.textContent = `Survival: ${state.meteor.timer.toFixed(1)}s / 18.0s`;

      const speed = dt * 60; // normalize to 60fps equivalent
      for (let i = meteorItems.length - 1; i >= 0; i--) {
        const m = meteorItems[i];
        m.y += m.vy * speed;
        m.el.style.top = `${m.y}px`;
        if (checkShipCollision(m)) {
          state.meteor.active = false;
          meteorStatus.className = 'status warn';
          meteorStatus.textContent = 'Hit! Try again ‚Äî you were close.';
          cancelAnimationFrame(meteorAnim);
          clearInterval(meteorInterval);
          setTimeout(startMeteorGame, 950);
          return;
        }
        if (m.y > meteorGame.clientHeight + 40) {
          m.el.remove();
          meteorItems.splice(i, 1);
        }
      }

      if (state.meteor.timer >= 18) {
        state.meteor.active = false;
        state.meteor.won = true;
        meteorStatus.className = 'status ok';
        meteorStatus.textContent = 'Perfect dodge!';
        toPlanet.disabled = false;
        clearInterval(meteorInterval);
        celebrateGameComplete();
        return;
      }

      meteorAnim = requestAnimationFrame(meteorLoop);
    }

    function startMeteorGame() {
      resetMeteor();
      state.meteor.active = true;
      meteorLastTime = 0;
      clearInterval(meteorInterval);
      meteorInterval = setInterval(spawnMeteor, 370);
      cancelAnimationFrame(meteorAnim);
      meteorAnim = requestAnimationFrame(meteorLoop);
    }

    function moveShip(clientX) {
      const rect = meteorGame.getBoundingClientRect();
      let x = (clientX - rect.left) / rect.width;
      x = Math.max(0.08, Math.min(0.92, x));
      shipPos.x = x;
      ship.style.left = `${x * 100}%`;
    }

    meteorGame.addEventListener('pointerdown', (e) => moveShip(e.clientX));
    meteorGame.addEventListener('pointermove', (e) => { if (state.meteor.active) moveShip(e.clientX); });
    window.addEventListener('mousemove', (e) => {
      if (scenes.meteor.classList.contains('active') && state.meteor.active) moveShip(e.clientX);
    });

    toPlanet.addEventListener('click', () => {
      const next = nextSceneFrom('meteor');
      showScene(next);
      cancelAnimationFrame(meteorAnim);
      clearInterval(meteorInterval);
    });

    // Skip button for testing
    document.getElementById('skipMeteor').addEventListener('click', () => {
      const next = nextSceneFrom('meteor');
      showScene(next);
      cancelAnimationFrame(meteorAnim);
      clearInterval(meteorInterval);
    });

    // Game 4: build-a-date planet (interactive)
    const savePlanet = document.getElementById('savePlanet');
    const toFinal = document.getElementById('toFinal');
    const planetStatus = document.getElementById('planetStatus');
    const planetSphere = document.getElementById('planetSphere');
    const planetRing = document.getElementById('planetRing');
    const planetLabel = document.getElementById('planetLabel');
    const planetCard = document.getElementById('planetCard');
    const planetSummary = document.getElementById('planetSummary');

    const planetColors = {
      'Pizza üçï': ['#ff6a3d', '#ff9a5c', '#8b2500'],
      'Cafe ‚òï': ['#c89b7b', '#8b6f4e', '#3d2b1f'],
      'Street food üåÆ': ['#ffd54f', '#ff8f00', '#5d4037'],
      'Dessert üç∞': ['#f8bbd0', '#f48fb1', '#880e4f'],
      'Sushi üç£': ['#80cbc4', '#26a69a', '#004d40'],
      'Home cooked üç≥': ['#a5d6a7', '#66bb6a', '#1b5e20']
    };
    const ringColors = {
      'Cozy walk üåô': 'rgba(255, 236, 179, 0.5)',
      'Music + chat üéß': 'rgba(186, 147, 255, 0.5)',
      'Movie night üé¨': 'rgba(255, 138, 128, 0.5)',
      'Sunset point üåÖ': 'rgba(255, 183, 77, 0.5)',
      'Stargazing üå†': 'rgba(130, 200, 255, 0.5)',
      'Adventure üé¢': 'rgba(105, 255, 155, 0.5)'
    };
    const spotGlows = {
      'Rooftop ‚ú®': 'rgba(255, 215, 0, 0.3)',
      'Park üå≥': 'rgba(76, 175, 80, 0.3)',
      'Cafe corner üïØÔ∏è': 'rgba(255, 183, 77, 0.3)',
      'Lakeside üíß': 'rgba(100, 181, 246, 0.3)',
      'Beach üèñÔ∏è': 'rgba(255, 224, 130, 0.3)',
      'Hilltop ‚õ∞Ô∏è': 'rgba(149, 117, 205, 0.3)'
    };

    function updatePlanetVisual() {
      const food = document.getElementById('foodChoice').value;
      const vibe = document.getElementById('vibeChoice').value;
      const spot = document.getElementById('spotChoice').value;

      // Update planet colors based on food
      if (food && planetColors[food]) {
        const c = planetColors[food];
        planetSphere.style.background = `radial-gradient(circle at 35% 35%, ${c[0]}, ${c[1]} 60%, ${c[2]})`;
      }

      // Update ring color based on vibe
      if (vibe && ringColors[vibe]) {
        planetRing.style.borderColor = ringColors[vibe];
        planetRing.style.width = '200px';
      }

      // Update glow based on spot
      if (spot && spotGlows[spot]) {
        planetSphere.style.boxShadow = `
          inset -30px -10px 40px rgba(0,0,0,0.4),
          inset 10px 10px 25px rgba(255,255,255,0.08),
          0 0 50px ${spotGlows[spot]},
          0 0 100px ${spotGlows[spot]}`;
      }

      // Build label
      const parts = [food, vibe, spot].filter(v => v);
      if (parts.length > 0) {
        planetLabel.textContent = parts.join(' ¬∑ ');
      } else {
        planetLabel.textContent = 'Your planet awaits...';
      }

      // Show card preview if all selected
      if (food && vibe && spot) {
        planetSummary.textContent = `${food} + ${vibe} at ${spot}`;
        planetCard.classList.add('visible');
      } else {
        planetCard.classList.remove('visible');
      }
    }

    document.getElementById('foodChoice').addEventListener('change', updatePlanetVisual);
    document.getElementById('vibeChoice').addEventListener('change', updatePlanetVisual);
    document.getElementById('spotChoice').addEventListener('change', updatePlanetVisual);

    savePlanet.addEventListener('click', () => {
      const food = document.getElementById('foodChoice').value;
      const vibe = document.getElementById('vibeChoice').value;
      const spot = document.getElementById('spotChoice').value;
      if (!food || !vibe || !spot) {
        planetStatus.className = 'status warn';
        planetStatus.textContent = 'Pick all three to build your planet!';
        return;
      }
      state.datePlan = `${food} + ${vibe} at ${spot}`;
      planetStatus.className = 'status ok';
      planetStatus.textContent = 'ü™ê Planet locked! Your date world is ready.';
      toFinal.disabled = false;
      celebrateGameComplete();
    });

    toFinal.addEventListener('click', () => {
      const next = nextSceneFrom('planet');
      if (next === 'final') {
        showFinal();
      } else {
        showScene(next);
      }
    });

    function typeWriter(el, text, speed, cb) {
      el.textContent = '';
      const cursor = document.createElement('span');
      cursor.className = 'typewriter-cursor';
      el.appendChild(cursor);
      let i = 0;
      function tick() {
        if (i < text.length) {
          el.insertBefore(document.createTextNode(text[i]), cursor);
          i++;
          setTimeout(tick, speed);
        } else {
          setTimeout(() => cursor.remove(), 1200);
          if (cb) cb();
        }
      }
      tick();
    }

    function showFinal() {
      // Stop shooting stars and star streaks once the journey is complete
      shootingStarsActive = false;
      clearInterval(shootingStarInterval);
      clearInterval(starStreakInterval);
      const msg = `Hey ${state.name}, I made this little cosmic game because I've realized I really like you and enjoy being around you. Would you like to go on a real date with me?`;
      document.getElementById('datePlan').textContent = state.datePlan ? `Date planet idea: ${state.datePlan}` : '';
      showScene('final');
      typeWriter(document.getElementById('finalMessage'), msg, 32);
    }

    // direct continuation if last selected game is not planet
    ['stars', 'constellation', 'memory', 'meteor'].forEach((g) => {
      const btnMap = { stars: toConstellation, constellation: toMemory, memory: toMeteor, meteor: toPlanet };
      btnMap[g].addEventListener('click', () => {
        const next = nextSceneFrom(g);
        if (next === 'final') showFinal();
      });
    });

    document.getElementById('yesBtn').addEventListener('click', () => {
      const response = document.getElementById('response');
      response.className = 'status ok';
      response.textContent = 'Yay! Cosmic success unlocked. Pick a time and send the plan ‚ú®';
      celebrateGameComplete();
    });
    document.getElementById('maybeBtn').addEventListener('click', () => {
      const response = document.getElementById('response');
      response.className = 'status warn';
      response.textContent = 'Totally fair üíô Thanks for taking the time to go through this universe.';
    });
    document.getElementById('friendsBtn').addEventListener('click', () => {
      const response = document.getElementById('response');
      response.className = 'status ok';
      response.textContent = 'I value our friendship the most! Thanks for being honest üíõ';
      celebrateGameComplete();
    });
    document.getElementById('restart').addEventListener('click', () => window.location.reload());

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ANIMATED COSMIC BACKGROUND (moving nebula + stars)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, sx: 0, sy: 0 };
    window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('touchmove', (e) => {
      mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY;
    }, { passive: true });

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function lerp(a, b, t) { return a + (b - a) * t; }

    // --- Nebula: pre-render to offscreen canvas (done ONCE, composited each frame) ---
    const nebCanvas = document.getElementById('nebula-canvas');
    const nctx = nebCanvas.getContext('2d');
    let nebulaLayers = []; // offscreen canvases for each nebula blob group

    function buildNebula() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      nebCanvas.width = Math.floor(w * devicePixelRatio);
      nebCanvas.height = Math.floor(h * devicePixelRatio);
      nctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

      // Create 3 offscreen nebula layers with different colors/positions
      const layerDefs = [
        {
          blobs: [
            { x: 0.2, y: 0.25, r: 0.25, h: 220, s: 75, l: 45, a: 0.13 },
            { x: 0.65, y: 0.15, r: 0.20, h: 240, s: 60, l: 40, a: 0.10 },
            { x: 0.4, y: 0.6, r: 0.22, h: 210, s: 70, l: 50, a: 0.08 },
          ]
        },
        {
          blobs: [
            { x: 0.75, y: 0.4, r: 0.28, h: 270, s: 55, l: 42, a: 0.10 },
            { x: 0.15, y: 0.55, r: 0.18, h: 200, s: 80, l: 48, a: 0.09 },
            { x: 0.5, y: 0.3, r: 0.30, h: 230, s: 65, l: 46, a: 0.11 },
          ]
        },
        {
          blobs: [
            { x: 0.35, y: 0.7, r: 0.20, h: 280, s: 50, l: 38, a: 0.07 },
            { x: 0.8, y: 0.65, r: 0.22, h: 250, s: 60, l: 44, a: 0.08 },
            { x: 0.1, y: 0.1, r: 0.24, h: 195, s: 75, l: 50, a: 0.10 },
          ]
        }
      ];

      nebulaLayers = layerDefs.map((layer, li) => {
        const oc = document.createElement('canvas');
        oc.width = Math.floor(w * 1.3);
        oc.height = Math.floor(h * 1.3);
        const octx = oc.getContext('2d');
        const scale = 1.3;

        for (const b of layer.blobs) {
          const cx = b.x * w * scale;
          const cy = b.y * h * scale;
          const cr = b.r * Math.max(w, h) * scale;
          const g = octx.createRadialGradient(cx, cy, 0, cx, cy, cr);
          g.addColorStop(0, `hsla(${b.h}, ${b.s}%, ${b.l}%, ${b.a})`);
          g.addColorStop(0.4, `hsla(${b.h + 15}, ${b.s - 10}%, ${b.l}%, ${b.a * 0.6})`);
          g.addColorStop(0.7, `hsla(${b.h + 25}, ${b.s - 20}%, ${b.l - 5}%, ${b.a * 0.25})`);
          g.addColorStop(1, 'rgba(0,0,0,0)');
          octx.fillStyle = g;
          octx.beginPath();
          octx.arc(cx, cy, cr, 0, Math.PI * 2);
          octx.fill();
        }
        return {
          canvas: oc,
          speed: 0.00004 + li * 0.000015,
          phaseX: li * 2.1, phaseY: li * 1.7,
          parallax: 0.008 + li * 0.006
        };
      });
    }

    function drawNebula(time) {
      const w = window.innerWidth;
      const h = window.innerHeight;
      nctx.clearRect(0, 0, w, h);
      const mx = (mouse.sx - w / 2);
      const my = (mouse.sy - h / 2);

      for (const layer of nebulaLayers) {
        const driftX = Math.sin(time * layer.speed + layer.phaseX) * w * 0.06;
        const driftY = Math.cos(time * layer.speed * 0.8 + layer.phaseY) * h * 0.04;
        const px = -w * 0.15 + driftX + mx * layer.parallax;
        const py = -h * 0.15 + driftY + my * layer.parallax;
        nctx.drawImage(layer.canvas, px, py, w * 1.3, h * 1.3);
      }
    }

    // --- Stars canvas (dense moving stars + interactive) ---
    const starCanvas = document.getElementById('stars');
    const sctx = starCanvas.getContext('2d');
    let skyStars = [];
    let shootingStars = [];
    let mouseTrail = [];

    function resizeSky() {
      starCanvas.width = Math.floor(window.innerWidth * devicePixelRatio);
      starCanvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      sctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      const w = window.innerWidth;
      const h = window.innerHeight;

      skyStars = [];
      // Dense far stars (tiny, lots)
      const farCount = Math.floor((w * h) / 2200);
      for (let i = 0; i < farCount; i++) {
        skyStars.push({
          x: Math.random() * w, y: Math.random() * h,
          r: rand(0.3, 1.0), a: rand(0.15, 0.55),
          d: rand(0.001, 0.004), hue: rand(200, 240),
          vx: rand(-0.02, 0.02), vy: rand(-0.01, 0.01),
          layer: 0
        });
      }
      // Mid stars
      const midCount = Math.floor((w * h) / 9000);
      for (let i = 0; i < midCount; i++) {
        skyStars.push({
          x: Math.random() * w, y: Math.random() * h * 0.9,
          r: rand(0.8, 1.7), a: rand(0.25, 0.75),
          d: rand(0.003, 0.01), hue: rand(195, 250),
          vx: rand(-0.04, 0.04), vy: rand(-0.02, 0.02),
          layer: 1
        });
      }
      // Bright near stars (few, large)
      const nearCount = Math.floor((w * h) / 45000);
      for (let i = 0; i < nearCount; i++) {
        skyStars.push({
          x: Math.random() * w, y: Math.random() * h * 0.85,
          r: rand(1.5, 2.8), a: rand(0.4, 0.95),
          d: rand(0.005, 0.016), hue: rand(190, 260),
          vx: rand(-0.06, 0.06), vy: rand(-0.03, 0.03),
          layer: 2
        });
      }

      shootingStars = [];
      mouseTrail = [];
      buildNebula();
      fitConstellationCanvas();
    }

    function spawnShootingStar(w, h) {
      const isBright = Math.random() < 0.3;
      const dir = Math.random() < 0.5 ? -1 : 1;
      shootingStars.push({
        x: dir > 0 ? rand(-20, w * 0.3) : rand(w * 0.7, w + 20),
        y: rand(10, h * 0.55),
        vx: dir * rand(2.5, 5.5),
        vy: rand(0.8, 2.2),
        life: isBright ? rand(160, 200) : rand(140, 180),
        t: 0,
        trail: [],
        bright: isBright,
        hue: rand(190, 280)
      });
    }

    function animateSky(timestamp) {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const time = timestamp || 0;

      // Smooth mouse
      mouse.sx = lerp(mouse.sx, mouse.x, 0.05);
      mouse.sy = lerp(mouse.sy, mouse.y, 0.05);

      // Draw nebula (composites pre-rendered layers)
      drawNebula(time);

      // Stars
      sctx.clearRect(0, 0, w, h);
      for (const st of skyStars) {
        st.a += st.d;
        if (st.a <= 0.08 || st.a >= 0.95) st.d *= -1;
        // Slow drift
        st.x += st.vx;
        st.y += st.vy;
        if (st.x < -5) st.x = w + 5;
        if (st.x > w + 5) st.x = -5;
        if (st.y < -5) st.y = h + 5;
        if (st.y > h + 5) st.y = -5;

        sctx.beginPath();
        sctx.arc(st.x, st.y, st.r, 0, Math.PI * 2);
        sctx.fillStyle = `hsla(${st.hue}, 80%, 88%, ${st.a})`;
        sctx.fill();

        // Bright stars get sparkle
        if (st.layer === 2 && st.a > 0.65) {
          const sp = (st.a - 0.65) * 2.5;
          sctx.strokeStyle = `hsla(${st.hue}, 60%, 90%, ${sp * 0.6})`;
          sctx.lineWidth = 0.5;
          const len = st.r * 2.5;
          sctx.beginPath();
          sctx.moveTo(st.x - len, st.y); sctx.lineTo(st.x + len, st.y);
          sctx.moveTo(st.x, st.y - len); sctx.lineTo(st.x, st.y + len);
          sctx.stroke();
        }
      }

      // Mouse glow
      const glowR = 130 + Math.sin(time * 0.0015) * 25;
      const glow = sctx.createRadialGradient(mouse.sx, mouse.sy, 0, mouse.sx, mouse.sy, glowR);
      const hue1 = (time * 0.01) % 360;
      glow.addColorStop(0, `hsla(${hue1}, 65%, 60%, 0.10)`);
      glow.addColorStop(0.5, `hsla(${hue1 + 30}, 55%, 50%, 0.03)`);
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      sctx.fillStyle = glow;
      sctx.beginPath();
      sctx.arc(mouse.sx, mouse.sy, glowR, 0, Math.PI * 2);
      sctx.fill();

      // Mouse trail
      if (Math.random() < 0.5) {
        mouseTrail.push({
          x: mouse.x + rand(-5, 5), y: mouse.y + rand(-5, 5),
          r: rand(1, 2.8), a: rand(0.3, 0.65),
          hue: (time * 0.025 + rand(-15, 15)) % 360,
          life: rand(18, 38), t: 0
        });
      }
      if (mouseTrail.length > 50) mouseTrail.splice(0, mouseTrail.length - 50);
      mouseTrail = mouseTrail.filter(p => p.t < p.life);
      for (const p of mouseTrail) {
        p.t++;
        p.y -= 0.35;
        const fade = 1 - p.t / p.life;
        sctx.beginPath();
        sctx.arc(p.x, p.y, p.r * fade, 0, Math.PI * 2);
        sctx.fillStyle = `hsla(${p.hue}, 75%, 78%, ${p.a * fade})`;
        sctx.fill();
      }

      // Shooting stars / comets (extra random spawns between intervals)
      if (shootingStarsActive && Math.random() < 0.05 && shootingStars.length < 15) spawnShootingStar(w, h);
      shootingStars = shootingStars.filter(m => m.t < m.life);
      for (const m of shootingStars) {
        m.t++;
        m.x += m.vx;
        m.y += m.vy;
        m.trail.push({ x: m.x, y: m.y });
        const maxTrail = m.bright ? 35 : 22;
        if (m.trail.length > maxTrail) m.trail.shift();
        const alpha = 1 - m.t / m.life;
        const hue = m.hue || 210;

        // Trail
        for (let i = 1; i < m.trail.length; i++) {
          const ta = (i / m.trail.length) * alpha;
          const lw = m.bright ? 3.5 * (i / m.trail.length) : 2.2 * (i / m.trail.length);
          sctx.strokeStyle = `hsla(${hue}, 60%, 82%, ${ta * 0.8})`;
          sctx.lineWidth = lw;
          sctx.beginPath();
          sctx.moveTo(m.trail[i - 1].x, m.trail[i - 1].y);
          sctx.lineTo(m.trail[i].x, m.trail[i].y);
          sctx.stroke();
        }

        // Head glow
        const headR = m.bright ? 4 : 2;
        sctx.beginPath();
        sctx.arc(m.x, m.y, headR, 0, Math.PI * 2);
        sctx.fillStyle = `hsla(${hue}, 50%, 92%, ${alpha})`;
        sctx.shadowBlur = m.bright ? 20 : 10;
        sctx.shadowColor = `hsla(${hue}, 65%, 70%, ${alpha * 0.7})`;
        sctx.fill();
        sctx.shadowBlur = 0;

        // Bright comets get an outer glow ring
        if (m.bright && alpha > 0.3) {
          const grd = sctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, 18);
          grd.addColorStop(0, `hsla(${hue}, 55%, 80%, ${alpha * 0.2})`);
          grd.addColorStop(1, 'rgba(0,0,0,0)');
          sctx.fillStyle = grd;
          sctx.beginPath();
          sctx.arc(m.x, m.y, 18, 0, Math.PI * 2);
          sctx.fill();
        }
      }



      requestAnimationFrame(animateSky);
    }

    // Guaranteed shooting stars every 500ms ‚Äî always 2+
    let shootingStarsActive = true;
    const shootingStarInterval = setInterval(() => {
      if (!shootingStarsActive) return;
      const w = window.innerWidth, h = window.innerHeight;
      // Always spawn 2
      spawnShootingStar(w, h);
      setTimeout(() => { if (shootingStarsActive) spawnShootingStar(w, h); }, rand(50, 250));
      // 60% chance of a 3rd
      if (Math.random() < 0.6) {
        setTimeout(() => { if (shootingStarsActive) spawnShootingStar(w, h); }, rand(250, 450));
      }
    }, 500);

    // Full-page star explosion celebration
    function celebrateGameComplete() {
      const overlay = document.createElement('canvas');
      overlay.style.cssText = 'position:fixed;inset:0;width:100%;height:100%;z-index:9999;pointer-events:none;';
      document.body.appendChild(overlay);
      const ctx = overlay.getContext('2d');
      const dpr = devicePixelRatio;
      overlay.width = window.innerWidth * dpr;
      overlay.height = window.innerHeight * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      const W = window.innerWidth, H = window.innerHeight;
      const cx = W / 2, cy = H / 2;

      // Flash
      const flash = document.createElement('div');
      flash.style.cssText = 'position:fixed;inset:0;background:rgba(200,230,255,0.15);z-index:9998;pointer-events:none;transition:opacity 0.6s;';
      document.body.appendChild(flash);
      setTimeout(() => { flash.style.opacity = '0'; }, 100);
      setTimeout(() => flash.remove(), 700);

      // Draw a star shape
      function drawStar(ctx, cx, cy, spikes, outerR, innerR) {
        let rot = -Math.PI / 2;
        let step = Math.PI / spikes;
        ctx.beginPath();
        for (let i = 0; i < spikes * 2; i++) {
          const r = i % 2 === 0 ? outerR : innerR;
          ctx.lineTo(cx + Math.cos(rot) * r, cy + Math.sin(rot) * r);
          rot += step;
        }
        ctx.closePath();
      }

      // Star particles ‚Äî ALL star-shaped (MORE STARRY!)
      const particles = [];
      for (let i = 0; i < 160; i++) { // Increased particle count
        const angle = (Math.PI * 2 * i) / 160 + rand(-0.15, 0.15); // Even distribution
        const speed = rand(3, 16);
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - rand(0, 3),
          outerR: rand(4, 14), // Slightly larger stars
          spikes: Math.random() < 0.3 ? 4 : (Math.random() < 0.6 ? 5 : 6), // 4, 5, or 6 spikes
          hue: rand(180, 320),
          sat: rand(70, 100), // More vibrant
          life: rand(60, 110),
          t: 0,
          gravity: rand(0.03, 0.09),
          spin: rand(-0.15, 0.15), // Faster spin
          rotation: rand(0, Math.PI * 2),
          trail: []
        });
      }

      let frame = 0;

      function animCelebration() {
        ctx.clearRect(0, 0, W, H);
        frame++;

        // (Removed expanding ring logic)

        // Star particles
        let alive = 0;
        for (const p of particles) {
          if (p.t >= p.life) continue;
          alive++;
          p.t++;
          p.vy += p.gravity;
          p.vx *= 0.992;
          p.x += p.vx;
          p.y += p.vy;
          p.rotation += p.spin;
          const fade = 1 - (p.t / p.life);
          const scale = fade;

          // Trail
          p.trail.push({ x: p.x, y: p.y });
          if (p.trail.length > 6) p.trail.shift();
          for (let ti = 0; ti < p.trail.length - 1; ti++) {
            const ta = (ti / p.trail.length) * fade * 0.3;
            ctx.beginPath();
            ctx.arc(p.trail[ti].x, p.trail[ti].y, p.outerR * 0.3 * scale, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${p.hue}, ${p.sat}%, 80%, ${ta})`;
            ctx.fill();
          }

          // Draw star
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.shadowBlur = 15;
          ctx.shadowColor = `hsla(${p.hue}, ${p.sat}%, 70%, ${fade * 0.6})`;
          // Draw star (make innerR smaller for sharper points = more "starry")
          drawStar(ctx, 0, 0, p.spikes, p.outerR * scale, p.outerR * 0.25 * scale);
          ctx.fillStyle = `hsla(${p.hue}, ${p.sat}%, 78%, ${fade})`;
          ctx.fill();
          ctx.shadowBlur = 0;

          // Inner glow
          drawStar(ctx, 0, 0, p.spikes, p.outerR * 0.55 * scale, p.outerR * 0.25 * scale);
          ctx.fillStyle = `hsla(${p.hue}, 40%, 95%, ${fade * 0.7})`;
          ctx.fill();

          // Cross sparkle on larger stars
          if (p.outerR > 6 && fade > 0.3) {
            const len = p.outerR * 2.5 * scale;
            ctx.strokeStyle = `hsla(${p.hue}, 50%, 90%, ${fade * 0.4})`;
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            ctx.moveTo(-len, 0); ctx.lineTo(len, 0);
            ctx.moveTo(0, -len); ctx.lineTo(0, len);
            ctx.stroke();
          }
          ctx.restore();
        }

        if (alive > 0 && frame < 130) {
          requestAnimationFrame(animCelebration);
        } else {
          overlay.remove();
        }
      }
      requestAnimationFrame(animCelebration);
    }

    const style = document.createElement('style');
    style.textContent = `
      @keyframes pop {
        from { transform: translateY(8px) scale(.5) rotate(0deg); opacity: 0; }
        to { transform: translateY(-18px) scale(1.5) rotate(20deg); opacity: 1; }
      }
    `;
    document.head.appendChild(style);

    resizeSky();
    requestAnimationFrame(animateSky);
    window.addEventListener('resize', resizeSky);

    // Star streaks: 2 glowing dots with trails fly left-to-right every 5 seconds
    function spawnStarStreaks() {
      for (let i = 0; i < 1; i++) {
        const el = document.createElement('div');
        el.className = 'star-streak';
        const startY = (10 + Math.random() * 50);
        el.style.setProperty('--start-y', startY + 'vh');
        el.style.top = startY + 'vh';
        el.style.animationDelay = (i * 0.8) + 's';
        el.style.animationDuration = (8 + Math.random() * 4) + 's';
        document.getElementById('star-container').appendChild(el);
        setTimeout(() => el.remove(), 13000);
      }
    }
    spawnStarStreaks();
    const starStreakInterval = setInterval(spawnStarStreaks, 5000);
  </script>
</body>

</html>